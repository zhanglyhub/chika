[{"content":" 1.给定序列$a,$选择任意区间$[l,r]$，将区间内数改为$l+r$，求$\\max{\\sum_{i=1}^na_i}$，$\\forall:[l,r]$都有，$\\sum_{i=l}^r{l+r}=\\sum_{i=l}^r2i$(可看作步长为二的等差数列)，构造$b_i=2i-a_i$，求$b$的最大子段和即可。Problem - C - Codeforces\n2.好题，给定$x,y,k$，每次删去$my,m\\in[1,2,3\u0026hellip;]$，求$x$次迭代后的$k$小值。序列几乎被认为是无限的，正难则反，考虑一次操作后$k$会出现在哪里，显然有$k\u0026rsquo;=k-\\lfloor\\frac{k}{y}\\rfloor$，$O(N)$的进行$x$轮迭代不足以通过此题，z这里可以进行变换$k\u0026rsquo;=k-\\lfloor\\frac{k-1}{y-1}\\rfloor$，有点类似于数论分块的思想，将序列分为大小为$y$的块，每次删去第一个数，令$s=\\lfloor\\frac{k-1}{y-1}\\rfloor$观察发现$s$不是每次在变的，考虑以$s$为步长最多迭代多少轮，显然有$\\frac{k-1}{y-1}\u0026gt;s+1$，解得答案就是$\\min(x,(s+1)(y-1)-k)/s+1)$Problem - D2 - Codeforces\n3.划分可重集$a$，将其众数加入可重集$s$求最大划分方案。考虑一个数什么时候不会成为众数,$cnt_{x\\notin S}\u0026lt;=\\sum_{c\\in S}cnt_c$，显然只要$maxcnt_{x\\notin S}\u0026lt;=\\sum_{c\\in S}$，经典问题，选一些数不超过$maxcnt_{x\\notin S}$的方案数，01背包即可Problem - D - Codeforces\n关于在KomariChika的trick中学math这档事\n4.统计好子序列的数量(定义具体看题)，首先这是一个组合数，发现直接不好算，$dp$状态数太多，考虑定义，任意一个个好子序列$T$，我们枚举$|\\frac{T}{2}|$的位置，合法子序列必然一部分出现在$|\\frac{T}{2}|$的前面和后边，设$T$的长度为$k$，$S$的前$|\\frac{T}{2}|$有$p$个字符后有$q$个字符则有$\\sum\\limits_{k\u0026gt;=1}\\binom{p}{k-1}\\binom{q}{k}$F - 1122 Subsequence 2复杂度$O(|S|)$\n$$ \\sum\\limits_{k\u0026gt;=1}\\binom{p}{k-1}\\binom{q}{k}=\\sum\\limits_{k1+k2=q-1}\\binom{p}{k_1}\\binom{q}{k2}\\\\\\\\\\=[x^{q-1}]\\sum_{k_1\u0026gt;=0}\\binom{p}{k_1}x^{k_1}\\sum_{k2\u0026gt;=0}\\binom{q}{k_2}x^{k_2}\\\\\\\\\\\\\\=x^{q-1}^{p}(1+x)^q=\\binom{p+q}{q-1}=\\binom{p+q}{p+1} $$\n$$\n5.发现性质如何高效处理，这道题你发现这字符串肯定要错位匹配，思维不要固化，尝试正反思考，正向去模拟不好搞，你就反向匹配找最近的匹配字符，这样问题就简化了许多，特别注意题目所给的数据量信息，这里有$n*k_{max}x$显然要写与$k$有关的算法复杂度$O(nk_{max})$Problem - 2164D - Codeforces\n同样，找到题目数学关系时，不要着急去码，构建大致框架比如这题D - 183183，一眼是这个$A10^{len(b)}+B=0$被$m$整除，化简后可知$B\\equiv-A10^{len(b)}:\\pmod M$，你考虑二分，这里还是有点$trick$的，预处理$len(b)$和$B:mod:M$之间的映射，对于每个数去二分考虑(数位长度短所以这样搞)有没有答案，就清楚了很多。\n6.给你一张图，求经过所有边回到出发点的最小花费，首先花费至少为$\\sum\\limits_{i=1}^{n}w_i$，考虑如何使传送花费最小化，定义传送的花费为$\\min\\limits_{i=u}^{v}w_i$，考虑什么情况才会使用传送，易想到欧拉路径，显然只有奇数度的边才会进行传送，问题转化为找到奇数度的点两两匹配使得花费最小，考虑对原图建出重构树，显然任意两个点之间的最小花费就是$\\min\\limits_{u,v\\in :odddegree}\\sum\\texttt{LCA}(u,v)$，显然在重构树中任意一个父节点$x$个子节点$u,v$的$\\texttt{LCA}$就是$x$，要注意的是在建重构树的时候如果两个连通分量已经连通了我们要更新当前的最小权值而不应该简单跳过，\n贪心匹配的时候如果两个左右子树都为奇数度点为偶数就地匹配，否则向上传递到父节点，要特别注意看清楚题意的定义是值还是索引。\n7.傻逼题，but，并查集还能这么玩，维护区域矩阵连通性时考虑可以为每个行维护一个并查集实现快速跳转可以做到$O(nm)$，开数组时切记$n\u0026lt;=m$否则会爆。\n8.肯定要按位来搞，相当于给每个数维护了一个集合，显然较大的数贡献更多，搞一个堆，每次从集合中取数即可。Problem - 2165C - Codeforces\n9.每次可以给序列单点加1整体乘2求最少操作次数使得序列$a=b$，显然乘2是更优的，显然最大乘二操作次数为$\\min\\limits_{i=1}^{n}\\log_2\\frac{b_i}{a_i}$，根据乘法分配律，显然把加1操作穿插到乘法之间是更好的，考虑第$k$次乘法操作，此时必然满足$a_i2^k\u0026lt;=b_i$，考虑此时进行一次加法操作，相当于给序列多加了$2^k$，所以总共进行的加法操作为$\\lfloor\\frac{b_i-a_i2^k}{2^k}\\rfloor=\\lfloor\\frac{b_i}{2^k}\\rfloor-a_i$，则此时我们距离$a_i$还有$b_i-a_i*2^k mod:2^k=b_i mod:2^k$，所以总共进行的加法操作为$\\texttt{popcount}(b_i:mod2^k)$，加起来即可。第二问求所以可能的方案数，设当前$a_i$进行了$c_i$次加法操作所以总可能数为$S!=(\\sum\\limits_{i=1}^{n}c_i)!$，但这样会算重，应为每个$a_i$位置进行的操作$c_i$本质上是没区别的给$(a_i,1)$和$(1,a_i)$没区别，所以要出他们的排列$\\prod\\limits_{i=1}^{n}c_i!$所以对于每个位置乘一个多项式系数即可$\\frac{\\sum\\limits_{i=1}^{n}c_i)!}{\\prod\\limits_{i=1}^{n}c_i!}$。c\n10.考虑$x+y=k$这条对角线，显然，任意一条从左上到右下的路径都是要经过这条对角线的，先预处理一个极左极右路径，极左路径不穿过障碍物的尽量靠左的合法路径，极右路径同理，任意合法路径必在这夹在两条路径之间，如果不存在显然答案就是$\\binom{n*m}{2}-1$,\n显然这两条路径的交是必ban的，只要ban掉其中一个点再随便搞一个都行，枚举这条极左路径上的每一个点，依次ban掉，计算新的路径极左路径，答案就是它和极右路径的交$O(nm)$。Cells Blocking upd:\n11.二分出最短时间，关键再于check函数，考虑关键点向上跳肯定是更优的，所以我们向上跳到时间范围内的最浅父节点将当前父节点标true表示当前父亲所管辖的子树都已经安排好了，跑一遍dfs，如果遇到标记直接返回，否则找是否存在一条路径从根节点到叶子节点。复杂度$O(n\\log^2n)$.P1084\n12.分治线性检测，固定x考虑，观察到这个和式$\\sum\\limits_{i=1}^{n}w_i|t-Y_i|$是一个线性下凸函数，直接判定$f(\\frac{a+b}{2})==\\frac{f(a)+f(b)}{2}$即可，不用想直接分治$a,b$，$O(n\\log V)$.·\nThupc2026\nA:神题我直接Orz，求$\\max\\limits_{i=l}^{r}\\text{LCA}(a_i,u)$，\nB:看一眼数据可以$O(nq)$的，考虑一个询问怎么算，如果一个串存在border当且仅当$\\exist len:s[l+len-1]=s[r-len+1]$，\n你发现可以mix一下，具体的令$t=reverse(s)$，则有$s_lt_ls_{l+1}t_{l+1}\u0026hellip;s_{r}t_{r}$，随便观察一下显然只需要统计前半部分的偶回文即可。\nJ:赛时看了一眼榜，过的人挺多的，想到了要判奇偶的，但是当时G给我心态调炸了然后\u0026hellip;..首先$n$是偶数无解，数学归纳法：当$n=2$时，显然，任何正整数的平方是2的偶次幂，假设n=k-2时成立，考虑n=k时，反证法，假设是有解的，则有$a_i+a_{i+1}=2^{b_i}$，则有$a_{k-1}+a_k\u0026lt;=2a_k\u0026lt;2(a_1+a_k)$，$a_1+a_k\u0026lt;=2a_k\u0026lt;2(a_{k-1}+a_k)$，则有，$2^{b_i-1}\u0026lt;2^{b_k+1},2^{b_k}\u0026lt;2^{b_{k-1}+1} \\to b_k=b_{k-1},a_1=a_{k-1}$.所以$\\prod\\limits_{i=1}^{k-2}(a_i+a_{i+1})=\\prod\\limits_{i=1}^{k-3}(a_i+a_{i+1})(a_{k-2}+a_1)=\\frac{\\prod\\limits_{i=1}^{k}(a_i+a_{i+1})(a_1+a_{k-2})}{(a_1+a_k)(a_{k-2}+a_{k-1})(a_k+a_{k-1})}$,化简可得$2^{2t-2b_k+1}$显然，所以n等于偶数无解。\n若n为奇数\u0026hellip;.没看懂\u0026hellip;..不过为啥过那么多\u0026hellip;.\n","permalink":"http://localhost:1313/posts/trick/","summary":"\u003cp\u003e\u003cimg alt=\"test\" loading=\"lazy\" src=\"/images/f.jpg\"\u003e\n1.给定序列$a,$选择任意区间$[l,r]$，将区间内数改为$l+r$，求$\\max{\\sum_{i=1}^na_i}$，$\\forall:[l,r]$都有，$\\sum_{i=l}^r{l+r}=\\sum_{i=l}^r2i$(可看作步长为二的等差数列)，构造$b_i=2i-a_i$，求$b$的最大子段和即可。\u003ca href=\"https://codeforces.com/contest/2169/problem/C\"\u003eProblem - C - Codeforces\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e2.好题，给定$x,y,k$，每次删去$m\u003cem\u003ey,m\\in[1,2,3\u0026hellip;]$，求$x$次迭代后的$k$小值。序列几乎被认为是无限的，正难则反，考虑一次操作后$k$会出现在哪里，显然有$k\u0026rsquo;=k-\\lfloor\\frac{k}{y}\\rfloor$，$O(N)$的进行$x$轮迭代不足以通过此题，z这里可以进行变换$k\u0026rsquo;=k-\\lfloor\\frac{k-1}{y-1}\\rfloor$，有点类似于数论分块的思想，将序列分为大小为$y$的块，每次删去第一个数，令$s=\\lfloor\\frac{k-1}{y-1}\\rfloor$观察发现$s$不是每次在变的，考虑以$s$为步长最多迭代多少轮，显然有$\\frac{k-1}{y-1}\u0026gt;s+1$，解得答案就是$\\min(x,(s+1)\u003c/em\u003e(y-1)-k)/s+1)$\u003ca href=\"https://codeforces.com/contest/2169/problem/D2\"\u003eProblem - D2 - Codeforces\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e3.划分可重集$a$，将其众数加入可重集$s$求最大划分方案。考虑一个数什么时候不会成为众数,$cnt_{x\\notin S}\u0026lt;=\\sum_{c\\in S}cnt_c$，显然只要$maxcnt_{x\\notin S}\u0026lt;=\\sum_{c\\in S}$，经典问题，选一些数不超过$maxcnt_{x\\notin S}$的方案数，01背包即可\u003ca href=\"https://codeforces.com/contest/2166/problem/D\"\u003eProblem - D - Codeforces\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e关于在KomariChika的trick中学math这档事\u003c/p\u003e\n\u003cp\u003e4.统计好子序列的数量(定义具体看题)，首先这是一个组合数，发现直接不好算，$dp$状态数太多，考虑定义，任意一个个好子序列$T$，我们枚举$|\\frac{T}{2}|$的位置，合法子序列必然一部分出现在$|\\frac{T}{2}|$的前面和后边，设$T$的长度为$k$，$S$的前$|\\frac{T}{2}|$有$p$个字符后有$q$个字符则有$\\sum\\limits_{k\u0026gt;=1}\\binom{p}{k-1}\\binom{q}{k}$\u003ca href=\"https://atcoder.jp/contests/abc433/tasks/abc433_f\"\u003eF - 1122 Subsequence 2\u003c/a\u003e复杂度$O(|S|)$\u003c/p\u003e\n\u003cp\u003e$$\n\\sum\\limits_{k\u0026gt;=1}\\binom{p}{k-1}\\binom{q}{k}=\\sum\\limits_{k1+k2=q-1}\\binom{p}{k_1}\\binom{q}{k2}\\\\\\\\\\=[x^{q-1}]\\sum_{k_1\u0026gt;=0}\\binom{p}{k_1}x^{k_1}\\sum_{k2\u0026gt;=0}\\binom{q}{k_2}x^{k_2}\\\\\\\\\\\\\\=\u003ca href=\"1+x\"\u003ex^{q-1}\u003c/a\u003e^{p}(1+x)^q=\\binom{p+q}{q-1}=\\binom{p+q}{p+1}\n$$\u003c/p\u003e\n\u003cp\u003e$$\u003c/p\u003e\n\u003cp\u003e5.发现性质如何高效处理，这道题你发现这字符串肯定要错位匹配，思维不要固化，尝试正反思考，正向去模拟不好搞，你就反向匹配找最近的匹配字符，这样问题就简化了许多，特别注意题目所给的数据量信息，这里有$n*k_{max}x$显然要写与$k$有关的算法复杂度$O(nk_{max})$\u003ca href=\"https://codeforces.com/problemset/problem/2164/D\"\u003eProblem - 2164D - Codeforces\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e同样，找到题目数学关系时，不要着急去码，构建大致框架比如这题\u003ca href=\"https://atcoder.jp/contests/abc433/tasks/abc433_d\"\u003eD - 183183\u003c/a\u003e，一眼是这个$A\u003cem\u003e10^{len(b)}+B=0$被$m$整除，化简后可知$B\\equiv-A\u003c/em\u003e10^{len(b)}:\\pmod M$，你考虑二分，这里还是有点$trick$的，预处理$len(b)$和$B:mod:M$之间的映射，对于每个数去二分考虑(数位长度短所以这样搞)有没有答案，就清楚了很多。\u003c/p\u003e\n\u003cp\u003e6.给你一张图，求经过所有边回到出发点的最小花费，首先花费至少为$\\sum\\limits_{i=1}^{n}w_i$，考虑如何使传送花费最小化，定义传送的花费为$\\min\\limits_{i=u}^{v}w_i$，考虑什么情况才会使用传送，易想到欧拉路径，显然只有奇数度的边才会进行传送，问题转化为找到奇数度的点两两匹配使得花费最小，考虑对原图建出重构树，显然任意两个点之间的最小花费就是$\\min\\limits_{u,v\\in :odddegree}\\sum\\texttt{LCA}(u,v)$，显然在重构树中\u003cstrong\u003e任意一个父节点$x$个子节点$u,v$的$\\texttt{LCA}$就是$x$\u003c/strong\u003e，要注意的是在建重构树的时候如果两个连通分量已经连通了我们要更新当前的最小权值而不应该简单跳过，\u003c/p\u003e\n\u003cp\u003e贪心匹配的时候如果两个左右子树都为奇数度点为偶数就地匹配，否则向上传递到父节点，要特别注意看清楚题意的\u003cstrong\u003e定义是值还是索引\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e7.傻逼题，but，并查集还能这么玩，维护区域矩阵连通性时考虑可以为每个行维护一个并查集实现快速跳转可以做到$O(nm)$，开数组时切记$n\u0026lt;=m$否则会爆。\u003c/p\u003e\n\u003cp\u003e8.肯定要按位来搞，相当于给每个数维护了一个集合，显然较大的数贡献更多，搞一个堆，每次从集合中取数即可。\u003ca href=\"https://codeforces.com/problemset/problem/2165/C\"\u003eProblem - 2165C - Codeforces\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e9.每次可以给序列单点加1整体乘2求最少操作次数使得序列$a=b$，显然乘2是更优的，显然最大乘二操作次数为$\\min\\limits_{i=1}^{n}\\log_2\\frac{b_i}{a_i}$，根据乘法分配律，显然把加1操作穿插到乘法之间是更好的，考虑第$k$次乘法操作，此时必然满足$a_i\u003cem\u003e2^k\u0026lt;=b_i$，考虑此时进行一次加法操作，相当于给序列多加了$2^k$，所以总共进行的加法操作为$\\lfloor\\frac{b_i-a_i\u003c/em\u003e2^k}{2^k}\\rfloor=\\lfloor\\frac{b_i}{2^k}\\rfloor-a_i$，则此时我们距离$a_i$还有$b_i-a_i*2^k mod:2^k=b_i mod:2^k$，所以总共进行的加法操作为$\\texttt{popcount}(b_i:mod2^k)$，加起来即可。第二问求所以可能的方案数，设当前$a_i$进行了$c_i$次加法操作所以总可能数为$S!=(\\sum\\limits_{i=1}^{n}c_i)!$，但这样会算重，应为每个$a_i$位置进行的操作$c_i$本质上是没区别的给$(a_i,1)$和$(1,a_i)$没区别，所以要出他们的排列$\\prod\\limits_{i=1}^{n}c_i!$所以对于每个位置乘一个多项式系数即可$\\frac{\\sum\\limits_{i=1}^{n}c_i)!}{\\prod\\limits_{i=1}^{n}c_i!}$。c\u003c/p\u003e\n\u003cp\u003e10.考虑$x+y=k$这条对角线，显然，任意一条从左上到右下的路径都是要经过这条对角线的，先预处理一个极左极右路径，极左路径不穿过障碍物的尽量靠左的合法路径，极右路径同理，任意合法路径必在这夹在两条路径之间，如果不存在显然答案就是$\\binom{n*m}{2}-1$,\u003c/p\u003e\n\u003cp\u003e显然这两条路径的交是必\u003ccode\u003eban\u003c/code\u003e的，只要\u003ccode\u003eban\u003c/code\u003e掉其中一个点再随便搞一个都行，枚举这条极左路径上的每一个点，依次ban掉，计算新的路径极左路径，答案就是它和极右路径的交$O(nm)$。\u003ca href=\"https://qoj.ac/contest/443/problem/833\"\u003eCells Blocking \u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eupd:\u003c/p\u003e\n\u003cp\u003e11.二分出最短时间，关键再于check函数，考虑关键点向上跳肯定是更优的，所以我们向上跳到时间范围内的最浅父节点将当前父节点标true表示当前父亲所管辖的子树都已经安排好了，跑一遍dfs，如果遇到标记直接返回，否则找是否存在一条路径从根节点到叶子节点。复杂度$O(n\\log^2n)$.\u003ca href=\"https://www.luogu.com.cn/problem/P1084\"\u003eP1084\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e12.分治线性检测，固定x考虑，观察到这个和式$\\sum\\limits_{i=1}^{n}w_i|t-Y_i|$是一个线性下凸函数，直接判定$f(\\frac{a+b}{2})==\\frac{f(a)+f(b)}{2}$即可，不用想直接分治$a,b$，$O(n\\log V)$.·\u003c/p\u003e\n\u003cp\u003eThupc2026\u003c/p\u003e\n\u003cp\u003eA:神题我直接Orz，求$\\max\\limits_{i=l}^{r}\\text{LCA}(a_i,u)$，\u003c/p\u003e\n\u003cp\u003eB:看一眼数据可以$O(nq)$的，考虑一个询问怎么算，如果一个串存在border当且仅当$\\exist len:s[l+len-1]=s[r-len+1]$，\u003c/p\u003e\n\u003cp\u003e你发现可以mix一下，具体的令$t=reverse(s)$，则有$s_lt_ls_{l+1}t_{l+1}\u0026hellip;s_{r}t_{r}$，随便观察一下显然只需要统计前半部分的偶回文即可。\u003c/p\u003e\n\u003cp\u003eJ:赛时看了一眼榜，过的人挺多的，想到了要判奇偶的，但是当时G给我心态调炸了然后\u0026hellip;..首先$n$是偶数无解，数学归纳法：当$n=2$时，显然，任何正整数的平方是2的偶次幂，假设n=k-2时成立，考虑n=k时，反证法，假设是有解的，则有$a_i+a_{i+1}=2^{b_i}$，则有$a_{k-1}+a_k\u0026lt;=2a_k\u0026lt;2(a_1+a_k)$，$a_1+a_k\u0026lt;=2a_k\u0026lt;2(a_{k-1}+a_k)$，则有，$2^{b_i-1}\u0026lt;2^{b_k+1},2^{b_k}\u0026lt;2^{b_{k-1}+1} \\to b_k=b_{k-1},a_1=a_{k-1}$.所以$\\prod\\limits_{i=1}^{k-2}(a_i+a_{i+1})=\\prod\\limits_{i=1}^{k-3}(a_i+a_{i+1})(a_{k-2}+a_1)=\\frac{\\prod\\limits_{i=1}^{k}(a_i+a_{i+1})(a_1+a_{k-2})}{(a_1+a_k)(a_{k-2}+a_{k-1})(a_k+a_{k-1})}$,化简可得$2^{2t-2b_k+1}$显然，所以n等于偶数无解。\u003c/p\u003e\n\u003cp\u003e若n为奇数\u0026hellip;.没看懂\u0026hellip;..不过为啥过那么多\u0026hellip;.\u003c/p\u003e","title":"KomariChika suki Data Structures"},{"content":" Suffix AutomatonG - Substring GameAC自动机P2292\nA new way to maintain interval by bitset\n1.it maybe unless\u0026hellip;when range is small,we can use square root decomposition on with bitset.For all query in $l,r$ ,maintain a answer bitset.if they are in the same block,use brute force ,else preform an $or$ operation on the block and answer.\n2.可持久化并查集，大概\u0026hellip;\u0026hellip;考虑为每个格子维护建节点，维护5个指针指向上下左右上一次更新的数值，维护集合$S(v)$表示以$v$为原点最大拓展的区域，将值$v$相同合并，显然答案就是集合数量，对于一次更新，新建一个节点，继承之前上下左右指针指向的信息$O(1)$，之后查新节点的上下左右是否合法如果他大就把他标为不合法，如果他的邻居大就把他的邻居标为不合法，如果相等就合并$O((nm+q)*\\alpha(nm+q))$.\n3.单点修改区间修改区间子序列异或最大值查询。令$b_i=a_i\\oplus a_{i-1}$，线段树维护$b$序列的线性基，对于区间修改相当于$b_l,b_{r+1}$两次单点修改，考虑区间查询，显然$\\max\\oplus_{i=l}^{r}a_i=\\max a_l\\oplus b[l+1\u0026hellip;r]$，再将$a_l$插入即可，复杂度$O((n+q\\log n)\\cdot m^2)$\nP11731 P11620，其实如果不带修可以考虑分治处理$[l\u0026hellip;mid]$的后缀线性基，处理$[mid+1\u0026hellip;r]$的前缀线性基\nupd1:考虑令$b_i=a_i\\oplus a_{i-1}$，则有$a_{l+1}=a_l\\oplus b_{l+1}\\to \\text{span}{a_l,a_{l+1}}=\\text{span}{a_l,a_l\\oplus b_{l+1}}\\to\\text{span}{a_l,b_{l+1}}$ 所以对于区修改为点修，查询$\\max\\oplus_{i=l}^{r}a_i=a_l\\cup b_{l+1\u0026hellip;r}$，线段树维护差分值，树状数组维护前缀，复杂度$O(\\log n\\log^2V)$.感觉悬啊，小优化：满秩的时候不用插入直接返回.(不过好像没啥用还跑的更慢了).\nupd2:想了好久都没有想到如何维护区间赋值，这大概需要ODT的思想？肯定是要离线下来的，线段树分治加到时间轴上，目前做到：$O(\\frac{\\log^3V}{w})$，区间赋值只能做到$O(\\frac{nmq}{w})$.\n4.分治预处理$i\u0026lt;j\\land a_i\u0026lt;=a_j$的数量维护维护全局BIT，分治时找到答案就再BIT当前位置加1，query的时候直接query(r)-query(l-1);复杂度$O(n\\log^2 n+q\\log n)$ Ynoi2005\n5.首先很容易有一个$O(nq\\log n)$的分治，好像过不了，考虑优化仔细观察，一个查询区间$[l\u0026hellip;r]$，一定会被这些小的分治区间覆盖，联想分块的思想，对于那些完整的分治区间(查询区间被整块包裹)，我们经行预处理计算维护$f_j=\\max\\limits_{j\u0026lt;i}{f_i,a_i}$,单调队列表都行，对于散块$O(n)$暴力，总复杂度$O(nq+n\\log^2n)$。\nupd:想了好久，还是不够深刻，考虑我们需要维护什么，有点想不明白这个倍增区间的样子，写了个分治预处理维护左右儿子的最优解，但是区间怎么锁定在那一块呢？还有数字组是炸空间的，？\nupd:不会，想不明白这个，暂时放弃。\n6.区间加，查询$\\forall(i,j),a_p\u0026gt;=y\\land t_j\u0026lt;=t_i$，显然不能cdq这带修改，既然不强制在线，考虑分治，具体的，建值域线段树，时间线线段树，借用扫描线的思想，$dfs$时间线段树，对于区间修改，直接在原线段树上搞$O(\\log n)$，对于查询操作这里我刚开始想的是stack，记一下历史值但是这是朴素的，只能做到$O(q^2\\log n\\log q)$，珂朵莉告诉你这可以线段树二分，于是你想了想，便有了接下来优秀的$O(q\\log q\\log n)$的解法，发现可以直接time segment tree 维护$[l\u0026hellip;r]$时间内的最小值，接下来，搜左右子树即可。P3863\n其实远不及lxl的分块\u0026hellip;\u0026hellip;\n","permalink":"http://localhost:1313/posts/hello-world/","summary":"\u003cp\u003e\u003cimg alt=\"test\" loading=\"lazy\" src=\"/images/c.jpg\"\u003e\nSuffix Automaton\u003ca href=\"https://atcoder.jp/contests/abc433/tasks/abc433_g\"\u003eG - Substring Game\u003c/a\u003eAC自动机\u003ca href=\"https://www.luogu.com.cn/problem/P2292\"\u003eP2292\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eA new way to maintain interval by bitset\u003c/p\u003e\n\u003cp\u003e1.it maybe unless\u0026hellip;when range is small,we can use square root decomposition on with bitset.For all query in $l,r$ ,maintain a answer bitset.if they are in the same block,use brute force ,else preform an $or$ operation on the block and answer.\u003c/p\u003e\n\u003cp\u003e2.可持久化并查集，大概\u0026hellip;\u0026hellip;考虑为每个格子维护建节点，维护5个指针指向上下左右上一次更新的数值，维护集合$S(v)$表示以$v$为原点最大拓展的区域，将值$v$相同合并，显然答案就是集合数量，对于一次更新，新建一个节点，继承之前上下左右指针指向的信息$O(1)$，之后查新节点的上下左右是否合法如果他大就把他标为不合法，如果他的邻居大就把他的邻居标为不合法，如果相等就合并$O((nm+q)*\\alpha(nm+q))$.\u003c/p\u003e\n\u003cp\u003e3.单点修改区间修改区间子序列异或最大值查询。令$b_i=a_i\\oplus a_{i-1}$，线段树维护$b$序列的线性基，对于区间修改相当于$b_l,b_{r+1}$两次单点修改，考虑区间查询，显然$\\max\\oplus_{i=l}^{r}a_i=\\max a_l\\oplus b[l+1\u0026hellip;r]$，再将$a_l$插入即可，复杂度$O((n+q\\log n)\\cdot m^2)$\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.luogu.com.cn/problem/P11731\"\u003eP11731\u003c/a\u003e \u003ca href=\"https://www.luogu.com.cn/problem/P11620\"\u003eP11620\u003c/a\u003e，其实如果不带修可以考虑分治处理$[l\u0026hellip;mid]$的后缀线性基，处理$[mid+1\u0026hellip;r]$的前缀线性基\u003c/p\u003e\n\u003cp\u003eupd1:考虑令$b_i=a_i\\oplus a_{i-1}$，则有$a_{l+1}=a_l\\oplus b_{l+1}\\to \\text{span}{a_l,a_{l+1}}=\\text{span}{a_l,a_l\\oplus b_{l+1}}\\to\\text{span}{a_l,b_{l+1}}$ \u003c/p\u003e\n\u003cp\u003e所以对于区修改为点修，查询$\\max\\oplus_{i=l}^{r}a_i=a_l\\cup b_{l+1\u0026hellip;r}$，线段树维护差分值，树状数组维护前缀，复杂度$O(\\log n\\log^2V)$.感觉悬啊，小优化：满秩的时候不用插入直接返回.(不过好像没啥用还跑的更慢了).\u003c/p\u003e","title":"KomariChika suki Data Structures"},{"content":"一名来自xi\u0026rsquo;an 的oier,为什么叫KomariChika,因为很喜欢这个人物\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e一名来自xi\u0026rsquo;an 的oier,为什么叫KomariChika,因为很喜欢这个人物\u003c/p\u003e","title":"About me"}]